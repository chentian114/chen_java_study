# 并发编程之线程基础

[toc]

## 学习建议

基础概念一定要记住

多练，独立练习实践

## 基础概念

**多核心CPU：**
- 多核心处理器（英语：Multi-core processor），又称多核微处理器，是在单个计算组件中加入两个或以上的独立实体中央处理单元（简称核心，英语：Core）。
- 这些核心可以分别独立地运行程序指令，利用并行计算的能力加快程序的运行速度。
- 通常把两个或更多独立处理器封装在一个单一集成电路（IC）中的方案会称为多核心处理器，而封装在不同IC中的独立处理器形成的计算机系统被称为多处理器。

**CPU核心数和线程数的关系**
- 多核心:
  - 也指单芯片多处理器( Chip Multi processors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。
  - 这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理
- 多线程: 
  - Simultaneous Multithreading.简称SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。
- 核心数、线程数:
  - 目前主流CPU都是多核的；
  - 增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的；
  - 一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程，
  - 但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系。

**CPU时间片轮转机制：**
- 平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？
  - 这是因为操作系统提供了一种CPU时间片轮转机制。
- 时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称RR调度。
  - 每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。
- 百度百科对CPU时间片轮转机制原理解释如下:
  - 如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。
  - 如果进程在时间片结束前阻塞或结束,则CPU当即进行切换。
  - 调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾。
- 时间片轮转调度中特别需要关注的是时间片的长度；
  - 从一个进程切换到另一个进程是需要一定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。
  - 假如进程切换( process switch)-有时称为上下文切换( context switch)，需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。
  - 结论可以归结如下：时间片设得太短会导致过多的进程切换,降低了CPU效率；而设得太长又可能引起对短的交互请求的响应变差。
  - 时间片大小的确定：1.系统对响应时间的要求 2.就绪队列中进程的数目 3.系统的处理能力
  - 将时间片设为 100ms 通常是一个比较合理的折衷。

**什么是进程和线程：**
- 进程是程序运行资源分配的最小单位：
  - 进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘IO等，同一进程中的多条线程共享该进程中的全部系统资源，而进程和进程之间是相互独立的。
  - 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。
  - 进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身，用户进程就是所有由用户启动的进程。
- 线程是CPU调度的最小单位,必须依赖于进程而存在
  - 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。
  - 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

**澄清并行和并发：**
- 并发:
  - 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。 
  - 指应用能够交替执行不同的任务；
  - 当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态。这种方式我们称之为并发(Concurrent)。
- 并行:
  - 指应用能够同时执行不同的任务；
  - 当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。
- 两者区别:
  - 一个是交替执行,一个是同时执行；
  - 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。

![1.并行与并发](https://img-blog.csdnimg.cn/20210331065904254.jpg)


**多线程程序的好处和注意事项：**
- 好处：
  - 充分利用CPU的资源
    - 因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核跑，
    - 如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,
    - 可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。
  - 加快响应用户的时间
  - 可以使你的代码模块化,异步化
- 注意事项：
  - 线程之间的安全性
    - 在同一个进程里面的多线程是资源共享的；
    - 例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的，若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。
  - 线程之间的死锁
    - 为了解决线程之间的安全性引入了Java的锁机制，不同的线程之间相互等待各自占有的锁，就会造成死锁问题；
  - 线程太多了会将服务器资源耗尽形成死机宕机
    - 某些系统资源是有限的,如文件描述符。
    - 多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。
    - 如果线程数相当大,或者某个资源的候选线程数远远超过了可用的资源数则最好使用资源池。
    - 一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。 

## 认识Java里的线程

**Java多线程示例：**
- 启动一个 main() 方法 Java 程序， 打印， main 线程启动时的线程情况；
- 使用 ManagementFactory.getThreadMXBean();  Java 虚拟机线程系统的管理接口，获取线程堆栈信息
- 线程说明：
  -  Monitor Ctrl-Break //监控Ctrl-Break中断信号的
  -  Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等
  -  Signal Dispatcher  // 分发处理发送给JVM信号的线程
  -  Finalizer  // 调用对象finalize方法的线程
  -  Reference Handler //清除Reference的线程
  -  main //main线程，用户程序入口

参考代码：[com.chen.java.enjoyedu.concurrent.ch1.OnlyMain](https://gitee.com/chentian114/chen_java_study)

**使用线程的三种方式：**
- 继承 Thread
- 实现 Runnable
- 实现 Callable + Future

**Thread和Runnable的区别：**
- Thread才是Java里对线程的唯一抽象，
- Runnable只是对任务（业务逻辑）的抽象。
- Thread可以接受任意一个Runnable的实例并执行。

**代码实践：使用三种方式创建线程**

参考代码：[com.chen.java.enjoyedu.concurrent.ch1.NewThread](https://gitee.com/chentian114/chen_java_study)

**停止线程执行：**
- 线程执行完成，线程自然终止
- 抛出异常退出
- 使用 suspend(),  resume(), stop(), 分别对应 暂停、恢复和停止，
  - suspend() 在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。
  - stop() 方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。
  - 已过期，不建议使用。
- 使用 中断：
  - 安全的中止则是其他线程通过调用某个线程A的interrupt()方法对其进行中断操作，中断好比其他线程对该线程发了中断通知，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。
  - 因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应；
  - 线程通过方法 this.isInterrupted() 来进行判断是否被中断，
  - 也可以调用静态方法 Thread.interrupted() 来进行判断当前线程是否被中断，不过Thread.interrupted() 会同时将中断标识位改写为false。
  - 如果一个线程处于了阻塞状态（如线程调用了Thread.sleep、Thread.join、Thread.wait等），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。
  - 不建议自定义一个取消标志位来中止线程的运行。
    - 因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。
    - 这种情况下，使用中断会更好，因为：
    - 一、一般的阻塞方法，如sleep等本身就支持中断的检查、
    - 二、检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。
  - 注意：处于死锁状态的线程无法被中断

**代码实践：安全的中断线程**
- 注意：使用中断时，如果线程执行方法中会抛出 InterruptedException 异常的方法，使用try...catch 捕获中断异常，在外部调用中断线程时，会被catch捕获，且线程的中断标志位为重置为false，需要在catch中重新调用一个 interrupt() 中断方法。
- 使用 自定义cancel变量 停止变量中断线程，会存在一些问题，当线程执行方法中存在阻塞方法时，无法起作用；可和 isInterrupt() 一起使用；

1. 使用 interrupt() 中断 继承 Thread 方式启动线程  
参考代码：[com.chen.java.enjoyedu.concurrent.ch1.EndThread](https://gitee.com/chentian114/chen_java_study)
2. 使用 interrupt() 中断 Runnable 方式启动线程  
参考代码：[com.chen.java.enjoyedu.concurrent.ch1.EndRunnable](https://gitee.com/chentian114/chen_java_study)
3. 线程执行方法中会抛出 InterruptedException 异常的方法，使用 interrupt() 中断线程  
参考代码：[com.chen.java.enjoyedu.concurrent.ch1.HasInterruptException](https://gitee.com/chentian114/chen_java_study)

**线程的生命周期与状态：**

![1.线程生命周期与状态](https://img-blog.csdnimg.cn/20210327113715294.png)

**线程常用方法和线程的状态**
- Thread类是Java里对线程概念的抽象，可以这样理解：
  - 我们通过new Thread()其实只是new出一个Thread的实例，还没有操作系统中真正的线程挂起钩来。
  - 只有执行了start()方法后，才实现了真正意义上的启动线程。
- start() 启动线程；
  - 让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法，start()方法不能重复调用，如果重复调用会抛出异常。
- run() 线程启动后执行的方法；
  - 是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，也可以被单独调用。
- yield() 将线程从运行转到可运行状态；
  - 使当前线程让出CPU占有权，但让出的时间是不可设定的。
  - 也不会释放锁资源。
  - 注意：并不是每个线程都需要这个锁的，而且执行yield( ) 的线程不一定就会持有锁，我们完全可以在释放锁后再调用yield方法。 
  - 所有执行 yield() 的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。
- join() 
  - 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。
  - 比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。

**线程的优先级**
- 在Java线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从1~10，
- 在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，
- 优先级高的线程分配时间片的数量要多于优先级低的线程。
- 设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。
- 在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。

**守护线程**
- Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。
- 这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。
- 可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。
- 主线程结束，守护线程也会结束；如垃圾回收线程就是Daemon线程。
- Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的try...finally块并不一定会执行。
- 在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。

**代码实践：守护线程使用**
- 在守护线程中使用 try..finally...块，检验 finally 块中语句是否一定会执行；

参考代码：[com.chen.java.enjoyedu.concurrent.ch1.DaemonThread](https://gitee.com/chentian114/chen_java_study)


## 相关链接

gitee地址：[https://gitee.com/chentian114/chen_java_study](https://gitee.com/chentian114/chen_java_study)

github地址：[https://github.com/chentian114/chen_java_study](https://github.com/chentian114/chen_java_study)

CSDN地址：[https://blog.csdn.net/chentian114/category_10956933.html](https://blog.csdn.net/chentian114/category_10956933.html)

## 公众号

![知行chen](https://img-blog.csdnimg.cn/20201019220227866.jpg)

## 参考

享学 Java课程 Mark

https://www.wiki-wiki.top/wiki/%E5%A4%9A%E6%A0%B8%E5%BF%83CPU

https://www.wiki-wiki.top/wiki/Simultaneous_multithreading

https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC/7256857

https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91